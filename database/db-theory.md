## Теория
- [Проблема N+1 и решение](#проблема-n1-и-решение)
- [Уровни изоляции бд](#уровни-изоляции-бд)
- [Уровни нормализации](#уровни-нормализации)
- [Способы оптимизации бд (индекс, шардирование, партиционирование)](#способы-оптимизации-бд-индекс-шардирование-партиционирование)
- [Горизонтальное и вертикальное масштабирование](#горизонтальное-и-вертикальное-масштабирование)

## Проблема N+1 и решение
     (или проблема "жадной" загрузки) - это частое явление при использовании ORM, когда при попытке загрузить данные из связанных таблиц происходит множественный запрос к базе данных вместо одного оптимизированного запроса.

Такая ситуация возникает тогда, когда модель данных имеет связь один ко многим или многие ко многим.

Например, предположим, что у нас есть модель, описывающая клиентов и заказы, где каждый клиент может иметь несколько заказов. Если мы используем ORM для загрузки списка клиентов и решаем получить список всех заказов каждого клиента, то в результате будет выполнено n + 1 запросов к базе данных, где n - количество клиентов, а 1 - запрос на загрузку списка клиентов. Таким образом, если у нас есть 1000 клиентов, то для загрузки списка всех заказов мы будем выполнять 1001 запрос.

Чтобы избежать проблемы n+1, можно использовать ORM-функции для загрузки связанных объектов сразу или использовать более оптимальные запросы к базе данных. Также можно использовать инструменты для профилирования и анализа производительности приложения, чтобы выявлять и оптимизировать медленные участки кода.


## Изоляция транзакций
Свойство изолированности говорит нам о том, что:
- в системе могут параллельно исполняться две и более транзакции;
- при этом транзакция должна уметь выполняться так, как будто она в сисетме одна;
- кроме того, если мы выполнили по отдельности набор транзакций параллельно, то при попытке посмотреть на все эти транзакции в совокупности мы должны увидеть, что их совместный результат также корректен.

## Проблемы (аномалии) при параллельной обработке транзакций
`Косая запись`  — аномалия, которая возникает при ситуации когда мы из двух разных транзакций пытаемся изменить одни и те же данные (например, ячейки А и В) так, что первая транзакция затронет ячейку A, а вторая — ячейку В и мы получим неконсистентный результат.

`Фантомная запись` — это аномалия, которая возникает в том случае, когда одна и та же транзакция пытается повторно считать данные из какой-то таблицы, но между двумя этими считываниями какая-то другая транзакция занесла изменения в эту таблицу. В таком случае при повторном чтении мы увидим новые данные, которых не было ранее.

`Неповторяемое чтение` — это аномалия, которая возникает при повторном чтении ячейки таблицы, в которую были между этими чтениями внесены изменения. Таким образом, при повторном чтении мы можем увидеть вовсе не те данные, что были там раньше.

`Грязное чтение` — это аномалия, которая возникает при чтении еще не зафиксированных другой транзакцией изменений. Таким образом, мы можем увидеть данные, которые еще даже не были помечены как внесенные в базу.


## Уровни изоляции бд
![alt text](image-3.png)

`Serializable` 

При этом уровне изоляции мы гарантируем полную упорядочиваемость всех совершаемых транзакций, вследствие чего не возникнет ни одна из аномалий, перечисленных выше. Пример:
```sql
create transaction isolation level serializable;
-- your query goes here
commit;
```

`Snapshot` 

Название этого уровня изоляции на русский язык можно перевести как слепок, что, на самом деле, приводит к тому, что если две транзакции совершаются прааллельно, то каждой из них выдают свой "слепок" базы данных в какой-то определенный момент.

После выполнения всех операций со слепком базы данных (удаление/запись/изменение/чтение) все изменения "вливаются" в основную версию базы. Транзакция будет завершена успешно, если в основной версии базы данных к моменту окончания транзакции ни в одной из ячеек базы, измененных в ходе транзакции, не было изменений за время ее выполнения. Таким образом, если две транзакции выполняли операции над разными частями базы данных, то конфликтов у нас не возникнет и соответствующее слияние произойдет безболезненно. Если же изменялись одни и те же данные, мы можем получить аномалию "косой записи" (см. выше).

Стоит отметить, что формально такого уровня изоляции нет в стандарте языка SQL.

`Repeatable read`

При данном уровне изоляции выполняется гарантия, что при повторном чтении одного и того же поля записи в базе мы будем получать одни и те же значения в ходе транзакции. Исключение составляют те изменения, которые мы сами внесли в базу.

В базах данных, которые реализуют изоляцию посредством блокировок обеспечение такого уровня изоляции будет выполняться за счет блокировки или отдельных записей в таблицах, или страниц в целом.

Пример создания такой транзакции:
```sql
create transaction isolation repeatable read;
-- your query goes here
commit;
```

`Read committed`
При этом уровне изоляции существует гарантия, что мы увидим любые изменения, которые были зафиксированы другими транзакциями. При этом можно заметить, что если мы дважды читаем информацию из одной ячейки, то между этими чтениями другая транзакция могла внести свои изменения, что влечет за собой проблему "неповторяемого чтения".

Стоит отметить, что при таком уровне изоляции базе данных не нужно полностью брать блокировку на запись или таблицу — в этом случае можно использовать частичную блокировку записей или страниц.

Пример создания такой транзакции:
```sql
create transaction isolation read committed;
-- your query goes here
commit;
```

`Read uncommitted`
При таком уровне изоляции транзакций у нас вовсе отсутствуют какие-либо блокировки, следовательно мы ничего не можем гарантировать пользователю. При таком уровне изоляции пользователь увидит любые текущие данные в базе данных, в том числе, он сможет увидеть "грязные данные" — то есть данные, которые еще не были зафиксированы ни одной из транзакций и впоследствии могут быть вовсе откачены.

Транзакции, работающие на уровне изоляции read uncommitted, могут только читать данные, но не изменять их.

Хорошо подойдет, чтобы узнать количество студентов, ведь нам необязательно знать точное количество.

Пример создания такой транзакции:
```sql
create transaction isolation read uncommitted;
-- your query goes here
commit;
```

Источник - [Транзакции. Параллельное исполнение. Уровни изоляции](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8._%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5._%D0%A3%D1%80%D0%BE%D0%B2%D0%BD%D0%B8_%D0%B8%D0%B7%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%B8#.D0.A3.D1.80.D0.BE.D0.B2.D0.BD.D0.B8_.D0.B8.D0.B7.D0.BE.D0.BB.D1.8F.D1.86.D0.B8.D0.B8_.D1.82.D1.80.D0.B0.D0.BD.D0.B7.D0.B0.D0.BA.D1.86.D0.B8.D0.B9)

## <span style="color: orange">Уровни нормализации



## <span style="color: orange">Способы оптимизации бд (индекс, шардирование, партиционирование)



## <span style="color: orange">Горизонтальное и вертикальное масштабирование
