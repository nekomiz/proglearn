Для вычисления степеней \( x^8 \), \( x^{10} \), \( x^{15} \) и \( x^{19} \) с учётом ограничений (только сложение, вычитание и умножение, а также только одна операция в каждом выражении), мы будем использовать метод последовательного умножения. Постараемся минимизировать количество операций, используя промежуточные результаты.

---

### Алгоритм для \( y = x^8 \):

1. Вычислим \( x^2 = x \cdot x \).
2. Вычислим \( x^4 = x^2 \cdot x^2 \).
3. Вычислим \( x^8 = x^4 \cdot x^4 \).

#### Программа на Pascal:

```pascal
program CalculateX8;

var
  x, x2, x4, x8: integer;

begin
  // Ввод значения x
  writeln('Введите значение x:');
  readln(x);

  // Шаг 1: Вычисление x^2
  x2 := x * x;

  // Шаг 2: Вычисление x^4
  x4 := x2 * x2;

  // Шаг 3: Вычисление x^8
  x8 := x4 * x4;

  // Вывод результата
  writeln('Результат y = x^8 = ', x8);
end.
```

#### Трассировка при \( x = 2 \):

1. \( x2 = 2 \cdot 2 = 4 \).
2. \( x4 = 4 \cdot 4 = 16 \).
3. \( x8 = 16 \cdot 16 = 256 \).

**Результат:** \( y = 256 \).

---

### Алгоритм для \( y = x^{10} \):

1. Вычислим \( x^2 = x \cdot x \).
2. Вычислим \( x^4 = x^2 \cdot x^2 \).
3. Вычислим \( x^8 = x^4 \cdot x^4 \).
4. Вычислим \( x^{10} = x^8 \cdot x^2 \).

#### Программа на Pascal:

```pascal
program CalculateX10;

var
  x, x2, x4, x8, x10: integer;

begin
  // Ввод значения x
  writeln('Введите значение x:');
  readln(x);

  // Шаг 1: Вычисление x^2
  x2 := x * x;

  // Шаг 2: Вычисление x^4
  x4 := x2 * x2;

  // Шаг 3: Вычисление x^8
  x8 := x4 * x4;

  // Шаг 4: Вычисление x^10
  x10 := x8 * x2;

  // Вывод результата
  writeln('Результат y = x^10 = ', x10);
end.
```

#### Трассировка при \( x = 2 \):

1. \( x2 = 2 \cdot 2 = 4 \).
2. \( x4 = 4 \cdot 4 = 16 \).
3. \( x8 = 16 \cdot 16 = 256 \).
4. \( x^{10} = 256 \cdot 4 = 1024 \).

**Результат:** \( y = 1024 \).

---

### Алгоритм для \( y = x^{15} \):

1. Вычислим \( x^2 = x \cdot x \).
2. Вычислим \( x^4 = x^2 \cdot x^2 \).
3. Вычислим \( x^8 = x^4 \cdot x^4 \).
4. Вычислим \( x^{12} = x^8 \cdot x^4 \).
5. Вычислим \( x^{15} = x^{12} \cdot x^2 \cdot x \).

#### Программа на Pascal:

```pascal
program CalculateX15;

var
  x, x2, x4, x8, x12, x15: integer;

begin
  // Ввод значения x
  writeln('Введите значение x:');
  readln(x);

  // Шаг 1: Вычисление x^2
  x2 := x * x;

  // Шаг 2: Вычисление x^4
  x4 := x2 * x2;

  // Шаг 3: Вычисление x^8
  x8 := x4 * x4;

  // Шаг 4: Вычисление x^12
  x12 := x8 * x4;

  // Шаг 5: Вычисление x^15
  x15 := x12 * x2 * x;

  // Вывод результата
  writeln('Результат y = x^15 = ', x15);
end.
```

#### Трассировка при \( x = 2 \):

1. \( x2 = 2 \cdot 2 = 4 \).
2. \( x4 = 4 \cdot 4 = 16 \).
3. \( x8 = 16 \cdot 16 = 256 \).
4. \( x^{12} = 256 \cdot 16 = 4096 \).
5. \( x^{15} = 4096 \cdot 4 \cdot 2 = 32768 \).

**Результат:** \( y = 32768 \).

---

### Алгоритм для \( y = x^{19} \):

1. Вычислим \( x^2 = x \cdot x \).
2. Вычислим \( x^4 = x^2 \cdot x^2 \).
3. Вычислим \( x^8 = x^4 \cdot x^4 \).
4. Вычислим \( x^{16} = x^8 \cdot x^8 \).
5. Вычислим \( x^{19} = x^{16} \cdot x^2 \cdot x \).

#### Программа на Pascal:

```pascal
program CalculateX19;

var
  x, x2, x4, x8, x16, x19: integer;

begin
  // Ввод значения x
  writeln('Введите значение x:');
  readln(x);

  // Шаг 1: Вычисление x^2
  x2 := x * x;

  // Шаг 2: Вычисление x^4
  x4 := x2 * x2;

  // Шаг 3: Вычисление x^8
  x8 := x4 * x4;

  // Шаг 4: Вычисление x^16
  x16 := x8 * x8;

  // Шаг 5: Вычисление x^19
  x19 := x16 * x2 * x;

  // Вывод результата
  writeln('Результат y = x^19 = ', x19);
end.
```

#### Трассировка при \( x = 2 \):

1. \( x2 = 2 \cdot 2 = 4 \).
2. \( x4 = 4 \cdot 4 = 16 \).
3. \( x8 = 16 \cdot 16 = 256 \).
4. \( x^{16} = 256 \cdot 256 = 65536 \).
5. \( x^{19} = 65536 \cdot 4 \cdot 2 = 524288 \).

**Результат:** \( y = 524288 \).

---

### Итог:
- Для каждой степени используется минимальное количество промежуточных переменных.
- Количество операций сведено к минимуму за счёт повторного использования промежуточных результатов.
- Трассировка показывает корректность вычислений.
