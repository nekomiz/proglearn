## Hibernate
- [<span style="color: orange">Какие условия существования/работы entity hibernate?</span>](#какие-условия-существованияработы-entity-hibernate)
- [<span style="color: orange">Когда происходит ошибка LazyInitilizationException, как ее не допустить?</span>](#когда-происходит-ошибка-lazyinitilizationexception-как-ее-не-допустить)
- [Проблема n+1, решение в Hibernate?](#проблема-n1-решение-в-hibernate)


## <span style="color: orange">Какие условия существования/работы entity hibernate?</span>

## <span style="color: orange">Когда происходит ошибка LazyInitilizationException, как ее не допустить?</span>

## Проблема n+1, решение в Hibernate?

>__N+1 SELECT проблема__ - это проблема, возникающая при использовании объектно-реляционного отображения (ORM) в базе данных. Она возникает, когда для получения связанных сущностей объекта выполняется N+1 дополнительных запросов к базе данных.

__Способы решения:__

- __Использование жадной загрузки (eager loading)__: при использовании ORM вы можете настроить запросы таким образом, чтобы они загружали все связанные сущности одним запросом, а не выполняли дополнительные запросы для каждой сущности. Это может быть достигнуто с помощью аннотаций или конфигурационных параметров ORM.
- __Использование пакетной загрузки (batch loading)__: при использовании ORM вы можете настроить запросы таким образом, чтобы они выполнялись пакетно, загружая несколько связанных сущностей одним запросом, вместо выполнения отдельного запроса для каждой сущности.
- __Использование кэширования__: вы можете использовать механизм кэширования ORM, чтобы избежать повторных запросов к базе данных для уже загруженных сущностей

Выбор конкретного подхода зависит от вашей ситуации и требований к производительности. Важно учитывать, что каждый подход имеет свои преимущества и ограничения, и выбор должен быть основан на анализе конкретной ситуации.