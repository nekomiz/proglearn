## Hibernate
- [<span style="color: orange">Какие условия существования/работы entity hibernate?</span>](#какие-условия-существованияработы-entity-hibernate)
- [<span style="color: orange">Когда происходит ошибка LazyInitilizationException, как ее не допустить?</span>](#когда-происходит-ошибка-lazyinitilizationexception-как-ее-не-допустить)
- [Проблема n+1, решение в Hibernate?](#проблема-n1-решение-в-hibernate)


## <span style="color: orange">Какие условия существования/работы entity hibernate?</span>
В Hibernate **entity** — это объект, который представляет собой запись в базе данных. Для того чтобы объект мог считаться сущностью (entity), он должен соответствовать ряду условий:

### Основные требования к сущности:

1. **Наличие идентификатора (ID)**:
   У каждой сущности должна быть уникальная идентификация, которая может быть представлена полем типа `Long`, `Integer` или другим типом, поддерживающим уникальность. Это поле должно быть помечено аннотацией `@Id`.
   
   ```java
   @Entity
   public class User {
       @Id
       private Long id;
       // другие поля...
   }
   ```

2. **Аннотации для определения сущности**:
   Класс, представляющий сущность, должен быть помечен аннотацией `@Entity`. Эта аннотация указывает Hibernate, что данный класс является сущностью и будет сохраняться в базе данных.

   ```java
   import javax.persistence.Entity;

   @Entity
   public class User { ... }
   ```

3. **Поля должны быть приватными или иметь геттеры/сеттеры**:
   Поля сущности могут быть объявлены как приватные (`private`), но тогда у них должны быть соответствующие методы доступа (геттеры и сеттеры). Это позволяет Hibernate работать с полями через рефлексию.

   ```java
   private String name;

   public String getName() {
       return name;
   }

   public void setName(String name) {
       this.name = name;
   }
   ```

4. **Конструктор без аргументов**:
   Hibernate требует наличия конструктора без параметров, так как при создании экземпляра сущности используется именно такой конструктор. Если вы создаете конструкторы с параметрами, обязательно добавьте пустой конструктор.

   ```java
   public User() {}
   ```

5. **Отсутствие финальных полей и методов**:
   Сущность не должна содержать финальные поля или методы, так как Hibernate использует прокси-классы для управления состоянием объектов, а финальные элементы нельзя изменять динамически.

6. **Соответствие таблицам базы данных**:
   По умолчанию имя таблицы в базе данных совпадает с именем класса сущности. Однако это поведение можно изменить с помощью аннотаций `@Table(name="имя_таблицы")`.

7. **Управление отношениями между сущностями**:
   В случае отношений между сущностями используются аннотации `@OneToMany`, `@ManyToOne`, `@ManyToMany` и другие. Эти аннотации определяют связи между объектами и соответствующими таблицами в базе данных.

8. **Поддержка сериализации**:
   Хотя это не строгое требование, рекомендуется реализовать интерфейс `Serializable` для всех классов-сущностей. Это полезно, когда объекты передаются между слоями приложения или сохраняются в сессии.

9. **Использование транзакций**:
   Все операции с сущностями должны выполняться внутри транзакционных блоков. Hibernate управляет состояниями объектов в рамках транзакций, поэтому корректная работа возможна только при соблюдении этого правила.

10. **Настройка конфигурации Hibernate**:
    Чтобы Hibernate смог управлять сущностями, необходимо правильно настроить конфигурацию (например, указать URL базы данных, драйвер JDBC, параметры подключения и т.п.). Обычно эта информация хранится в файле `hibernate.cfg.xml` или в классе конфигурации.

### Дополнительные моменты:

- **Кэширование**: Hibernate поддерживает кэширование первого уровня (session cache) и второго уровня (second-level cache). Кэширование помогает уменьшить количество запросов к базе данных и повысить производительность.
  
- **Lazy loading**: По умолчанию Hibernate загружает все данные сразу, однако можно использовать ленивую загрузку (`lazy loading`) для некоторых связей, чтобы избежать загрузки больших объемов данных за раз.

Таким образом, соблюдение этих требований гарантирует правильную работу сущностей в Hibernate и эффективное взаимодействие с базой данных.
## Когда происходит ошибка LazyInitilizationException, как ее не допустить?
Во время выполнения запроса закрылась транзакция.
Решения:
1) __@Transactional__: Эта аннотация, применённая к методу сервиса, позволяет поддерживать сессию открытой в течение всего времени выполнения метода, что обеспечивает доступность коллекции.
2) __Жадная загрузка__: Возможно применение жадной загрузки коллекций через аннотации @OneToMany(fetch = FetchType.EAGER) или @ManyToMany(fetch = FetchType.EAGER) в классе сущности.
3) __Инициализация Hibernate__: Применимо использование Hibernate.initialize(entity.getCollection()) для явной инициализации коллекции во время активной сессии.

## Проблема n+1, решение в Hibernate?

>__N+1 SELECT проблема__ - это проблема, возникающая при использовании объектно-реляционного отображения (ORM) в базе данных. Она возникает, когда для получения связанных сущностей объекта выполняется N+1 дополнительных запросов к базе данных.

__Способы решения:__

- __Использование жадной загрузки (eager loading)__: при использовании ORM вы можете настроить запросы таким образом, чтобы они загружали все связанные сущности одним запросом, а не выполняли дополнительные запросы для каждой сущности. Это может быть достигнуто с помощью аннотаций или конфигурационных параметров ORM.
- __Использование пакетной загрузки (batch loading)__: при использовании ORM вы можете настроить запросы таким образом, чтобы они выполнялись пакетно, загружая несколько связанных сущностей одним запросом, вместо выполнения отдельного запроса для каждой сущности.
- __Использование кэширования__: вы можете использовать механизм кэширования ORM, чтобы избежать повторных запросов к базе данных для уже загруженных сущностей

Выбор конкретного подхода зависит от вашей ситуации и требований к производительности. Важно учитывать, что каждый подход имеет свои преимущества и ограничения, и выбор должен быть основан на анализе конкретной ситуации.
