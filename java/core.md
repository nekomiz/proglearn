# Java core
- [В чем разница между checked и unchecked исключениями?](#в-чем-разница-между-checked-и-unchecked-исключениями)
- [Какие существуют unchecked exception?](#какие-существуют-unchecked-exception)
- [Какие особенности использования оператора try...catch знаете?](#какие-особенности-использования-оператора-trycatch-знаете)
- [Что представляет из себя ошибки класса Error?](#что-представляет-из-себя-ошибки-класса-error)
- [В чем разница между error и exception?](#в-чем-разница-между-error-и-exception)
- [Опишите иерархию исключений](#опишите-иерархию-исключений)
- [Возможно ли использование блока try-finally (без catch)?](#возможно-ли-использование-блока-try-finally-без-catch)
- [Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
- [Какой оператор позволяет принудительно выбросить исключение?](#какой-оператор-позволяет-принудительно-выбросить-исключение)
- [О чем говорит ключевое слово throws?](#о-чем-говорит-ключевое-слово-throws)
- [Как написать собственное («пользовательское») исключение?](#как-написать-собственное-«пользовательское»-исключение)
- [Когда в приложении может быть выброшено исключение `ClassCastException`](#когда-в-приложении-может-быть-выброшено-исключение-classcastexception)
- [Что вы знаете о `OutOfMemoryError`?](#что-вы-знаете-о-outofmemoryerror)
- [Опишите работу блока _try-catch-finally_](#опишите-работу-блока-try-catch-finally)
- [Что такое механизм try-with-resources?](#что-такое-механизм-try-with-resources)
- [Может ли один блок catch отлавливать сразу несколько исключений?](#может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)
- [Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?](#предположим-есть-метод-который-может-выбросить-ioexception-и-filenotfoundexception-в-какой-последовательности-должны-идти-блоки-catch-сколько-блоков-catch-будет-выполнено)
- [Что такое generics?](#что-такое-generics)
- [Что такое «интернационализация», «локализация»?](#что-такое-«интернационализация»-«локализация»)
- [Что такое класс `Object`? Какие в нем есть методы?](#что-такое-класс-object-какие-в-нем-есть-методы)
- [Кто __НЕ__ наследуется от класса `Object`?](#кто-не-наследуется-от-класса-object)

## В чем разница между checked и unchecked исключениями?
В Java исключения объединены в иерархическую структуру классов, начиная с класса Throwable. Все исключения делятся на два типа:

+ __checked (контролируемые/проверяемые исключения)__ должны быть обработаны в коде программы, иначе код не будет скомпилирован
+ __unchecked (неконтролируемые/непроверяемые исключения)__ (наследники класса RuntimeException) могут возникнуть в любой части кода и не требуют явной обработки

## Какие существуют unchecked exception?
Наиболее часто встречающиеся: 
- ArithmeticException, 
- ClassCastException, 
- ConcurrentModificationException, 
- IllegalArgumentException, 
- IllegalStateException, 
- IndexOutOfBoundsException, 
- NoSuchElementException, 
- NullPointerException, 
- UnsupportedOperationException.

## Какие особенности использования оператора try...catch знаете?
Оператор try-catch используется в Java для обработки исключений. Вот некоторые его особенности:

+ Блок try содержит код, который может породить исключение.
+ Блок catch содержит код, который будет выполняться при возникновении исключения. Мы можем указать тип исключения, которое мы хотим обработать, и обрабатывать их по отдельности.
+ Один блок try может иметь несколько блоков catch, каждый из которых обрабатывает определенный тип исключения.
+ Можно использовать блок finally, который содержит код, который нужно выполнить в любом случае после завершения блока try-catch. Например, можно закрыть файл или соединение с базой данных в блоке finally.
+ Если исключение не было обработано в блоке try-catch, оно передается в более высокий уровень иерархии вызовов, где может быть обработано в другом блоке try-catch.

## Что представляет из себя ошибки класса Error?
Ошибки класса Error представляют собой наиболее серьёзные проблемы уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не рекомендуется.

## В чем разница между error и exception?
В Java классы Exception и Error являются потомками класса Throwable и представляют разные типы проблем, которые могут возникнуть в программе.

Exception обычно возникает из-за ошибок в коде программы или некоторых внешних условий, таких как некорректный ввод пользователя, проблемы с соединением или файловой системой. Исключения должны быть обработаны программным кодом при помощи блока try-catch или выброса исключения для более высокого уровня.

С другой стороны, Error обычно возникает в критических ситуациях, связанных с работой JVM. Это могут быть проблемы с памятью, отказ жесткого диска, невозможность загрузки класса и т.д. Стандартная рекомендация для программирования на Java - не пытаться обрабатывать ошибки (Error), так как они обычно не поддаются коррекции на уровне программного кода.

Класс Error и его подклассы не требуют перехвата и обработки, поскольку они обычно возникают в критических ситуациях, когда дальнейшее выполнение программы может быть проблематичным. Обычно лучшим решением будет прервать выполнение программы и сообщить об ошибке пользователю или администратору системы.

## Опишите иерархию исключений
![alt text](image.png)

## Возможно ли использование блока try-finally (без catch)?
Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок `catch`, в котором будет обрабатываться необходимое исключение.

## Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
Может и оно будет передано в виртуальную машину Java (JVM).

## Какой оператор позволяет принудительно выбросить исключение?
Это оператор `throw`:

```java
throw new Exception();
```

## О чем говорит ключевое слово `throws`?
Модификатор `throws` прописывается в заголовке метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.

## Как написать собственное («пользовательское») исключение?
Необходимо унаследоваться от базового класса требуемого типа исключений (например, от `Exception` или `RuntimeException`).

```java
class CustomException extends Exception {
    public CustomException() {
        super();
    }

    public CustomException(final String string) {
        super(string + " is invalid");
    }

    public CustomException(final Throwable cause) {
        super(cause);
    }
}
```

## Когда в приложении может быть выброшено исключение `ClassCastException`?
`ClassCastException` (потомок `RuntimeException`) - исключение, которое будет выброшено при ошибке приведения типа.

## Что вы знаете о `OutOfMemoryError`?
`OutOfMemoryError` выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.

Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип `OutOfMemoryError` зависит от того, в какой из них не хватило места:

+ `java.lang.OutOfMemoryError: Java heap space`: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами `-Xms` и `-Xmx`.
+ `java.lang.OutOfMemoryError: PermGen space`: (до версии Java 8) Данная ошибка возникает при нехватке места в _Permanent_ области, размер которой задается параметрами `-XX:PermSize` и `-XX:MaxPermSize`.
+ `java.lang.OutOfMemoryError: GC overhead limit exceeded`: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра `-XX:-UseGCOverheadLimit`.
+ `java.lang.OutOfMemoryError: unable to create new native thread`: Выбрасывается, когда нет возможности создавать новые потоки.

## Опишите работу блока _try-catch-finally_.
```java
try { 
    //код, который потенциально может привести к исключительной ситуации 
} 
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //код обработки исключительной ситуации
} 
finally {
    //необязательный блок, код которого выполняется в любом случае
}
```

## Что такое механизм try-with-resources?
Данная конструкция, которая появилась в Java 7, позволяет использовать блок _try-catch_ не заботясь о закрытии ресурсов, используемых в данном сегменте кода.
Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally`, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.Autocloseable`.

Общий вид конструкции:

```java
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
```

Стоит заметить, что блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finally`.

## Может ли один блок catch отлавливать сразу несколько исключений?
Да, с версии Java 7

## Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?
__Общее правило:__ обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок `catch(Exception ex) {}`, иначе все дальнейшие блоки `catch()` уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику `catch(Exception ex)`.

Таким образом, исходя из факта, что `FileNotFoundException extends IOException` сначала нужно обработать `FileNotFoundException`, а затем уже `IOException`:

```java
void method() {
    try {
        //...
    } catch (FileNotFoundException ex) {
        //...
    } catch (IOException ex) {
        //...
    }
}
```


## Что такое generics?
__Generics__ - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.

Примером использования обобщенных типов может служить _Java Collection Framework_. Так, класс `LinkedList<E>` - типичный обобщенный тип. Он содержит параметр `E`, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать `LinkedList`, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа `LinkedList<String>`, `LinkedList<Integer>` и т.п.

## Что такое «интернационализация», «локализация»?
__Интернационализация (internationalization)__ - способ создания приложений, при котором их можно легко адаптировать для разных аудиторий, говорящих на разных языках.

__Локализация (localization)__ -  адаптация интерфейса приложения под несколько языков. Добавление нового языка может внести определенные сложности в локализацию интерфейса.

## Что такое класс `Object`? Какие в нем есть методы?
`Object` это базовый класс для всех остальных объектов в Java. Любой класс наследуется от `Object` и, соответственно, наследуют его методы:

`public boolean equals(Object obj)` – служит для сравнения объектов по значению;

`int hashCode()` – возвращает hash код для объекта;

`String toString()` – возвращает строковое представление объекта;

`Class getClass()` – возвращает класс объекта во время выполнения;

`protected Object clone()` – создает и возвращает копию объекта;

`void notify()` – возобновляет поток, ожидающий монитор;

`void notifyAll()` – возобновляет все потоки, ожидающие монитор;

`void wait()` – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`void wait(long timeout)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`void wait(long timeout, int nanos)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`protected void finalize()` – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

## Кто НЕ наследуется от класса `Object`?
- Класс Object не наследуется от себя же, так как он является суперклассом. От него наследуются другие классы.
- Интерфейсы тоже не наследуются от object, но при реализации интерфейса объект будет наследовать и object
- тип данных enum тоже не наследуется от Object, потому что наследуется от Enum.